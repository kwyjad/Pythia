name: Collect diagnostics
description: Gathers resolver CI diagnostics and packages a standardized artifact
inputs:
  job_name:
    description: Short job name used for naming artifacts (e.g., fast-tests, pipeline-smoke)
    required: true
runs:
  using: composite
  steps:
    - name: Collect diagnostics bundle
      shell: bash
      run: |
        set -euo pipefail
        JOB="${{ inputs.job_name }}"
        OUT="dist/diagnostics-${JOB}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}.zip"
        mkdir -p dist diagnostics "diagnostics/${JOB}"

        # Versions
        {
          echo "== VERSIONS =="
          python -V || true
          pip --version || true
          pip freeze || true
          duckdb --version || true
          uname -a || true
        } > "diagnostics/${JOB}/versions.txt" 2>&1 || true

        # Environment snapshot (limited to important vars)
        {
          echo "== IMPORTANT ENVS =="
          env | grep -E '^(RESOLVER_|PERIOD_LABEL|GITHUB_)' || true
        } > "diagnostics/${JOB}/environment.txt" 2>&1 || true

        # Git state
        {
          echo "== GIT STATE =="
          git rev-parse HEAD || true
          git status --porcelain || true
        } > "diagnostics/${JOB}/git.txt" 2>&1 || true

        # Data directories
        {
          echo "== STAGING =="
          ls -R data/staging || true
        } > "diagnostics/${JOB}/staging.txt" 2>&1 || true

        {
          echo "== SNAPSHOTS =="
          ls -R data/snapshots || true
        } > "diagnostics/${JOB}/snapshots.txt" 2>&1 || true

        # Resolver logs
        {
          echo "== RESOLVER LOGS =="
          ls -R resolver/logs || true
        } > "diagnostics/${JOB}/resolver_logs.txt" 2>&1 || true

        if [ -f ".ci/diagnostics/SUMMARY.md" ]; then
          cp ".ci/diagnostics/SUMMARY.md" "diagnostics/${JOB}/SUMMARY.md"
        fi

        # DuckDB summary (best-effort)
        python - <<'PY' > "diagnostics/${JOB}/duckdb.txt" 2>&1 || true
import os
import sys
try:
    import duckdb
except Exception as exc:  # pragma: no cover - diagnostics only
    print(f"duckdb import failed: {exc}")
    sys.exit(0)

db_path = os.environ.get("RESOLVER_DB_PATH", "data/resolver.duckdb")
print(f"Inspecting DuckDB database at {db_path}")
try:
    con = duckdb.connect(db_path)
except Exception as exc:  # pragma: no cover - diagnostics only
    print(f"unable to open database: {exc}")
    sys.exit(0)

for table in ("facts_raw", "facts_resolved", "facts_deltas"):
    try:
        count = con.execute(f"SELECT COUNT(*) FROM {table}").fetchone()[0]
        print(f"{table}: {count}")
    except Exception as exc:  # pragma: no cover - diagnostics only
        print(f"{table}: unavailable ({exc})")

con.close()
PY

        (cd diagnostics && zip -rq "../${OUT}" .) || true
        echo "ARTIFACT_PATH=${OUT}" >> "$GITHUB_ENV"
